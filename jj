diff --git a/src/main/java/org/aqa/webrun/phase2/Phase2Util.scala b/src/main/java/org/aqa/webrun/phase2/Phase2Util.scala
index c9d7b766..f99751bd 100755
--- a/src/main/java/org/aqa/webrun/phase2/Phase2Util.scala
+++ b/src/main/java/org/aqa/webrun/phase2/Phase2Util.scala
@@ -46,13 +46,13 @@ import java.util.Date
 import scala.xml.Elem
 
 /**
-  * Utilities for Phase 2.
-  */
+ * Utilities for Phase 2.
+ */
 object Phase2Util extends Logging {
 
   /**
-    * Get the plan that this image references.  If it does not reference exactly one it will throw an exception.
-    */
+   * Get the plan that this image references.  If it does not reference exactly one it will throw an exception.
+   */
   def referencedPlanUID(rtimage: AttributeList): String = {
     val planSeqList = DicomUtil.seqToAttr(rtimage, TagByName.ReferencedRTPlanSequence)
     val planUidList = planSeqList.map(al => al.get(TagFromName.ReferencedSOPInstanceUID).getSingleStringValueOrNull).filter(uid => uid != null).distinct
@@ -61,8 +61,8 @@ object Phase2Util extends Logging {
   }
 
   /**
-    * Determine if the given image references the given plan.
-    */
+   * Determine if the given image references the given plan.
+   */
   def imageReferencesPlan(plan: AttributeList, image: AttributeList): Boolean = {
     try {
       val planUID = plan.get(TagFromName.SOPInstanceUID).getSingleStringValueOrNull
@@ -80,11 +80,11 @@ object Phase2Util extends Logging {
   }
 
   /**
-    * Get all RTPLAN files, including any that were just now downloaded and any that are in the
-    * shared directory.  If a plan is found more than once then return only one
-    * occurrence of it.  If the plan occurs both in the shared directory and was
-    * downloaded, then prefer the one in the shared directory.
-    */
+   * Get all RTPLAN files, including any that were just now downloaded and any that are in the
+   * shared directory.  If a plan is found more than once then return only one
+   * occurrence of it.  If the plan occurs both in the shared directory and was
+   * downloaded, then prefer the one in the shared directory.
+   */
   def getPlanList(dicomList: Seq[DicomFile]): Seq[DicomFile] = {
     val configuredPlans: Seq[DicomFile] = {
       try {
@@ -96,22 +96,21 @@ object Phase2Util extends Logging {
       }
     }
 
-    val downloadedPlans: Seq[DicomFile] =
-      try {
-        val configSopList = configuredPlans.map(c => Util.sopOfAl(c.attributeList.get))
-        dicomList.filter(df => df.isRtplan).filter(d => !configSopList.contains(Util.sopOfAl(d.attributeList.get)))
-      } catch {
-        case t: Throwable =>
-          logger.warn("Unexpected problem while getting RTPLAN: " + t)
-          Seq[DicomFile]()
-      }
+    val downloadedPlans: Seq[DicomFile] = try {
+      val configSopList = configuredPlans.map(c => Util.sopOfAl(c.attributeList.get))
+      dicomList.filter(df => df.isRtplan).filter(d => !configSopList.contains(Util.sopOfAl(d.attributeList.get)))
+    } catch {
+      case t: Throwable =>
+        logger.warn("Unexpected problem while getting RTPLAN: " + t)
+        Seq[DicomFile]()
+    }
 
     DicomFile.distinctSOPInstanceUID(configuredPlans ++ downloadedPlans)
   }
 
   /**
-    * If the serial number for the machine is not already set, then set it by using the DeviceSerialNumber in the RTIMAGE.
-    */
+   * If the serial number for the machine is not already set, then set it by using the DeviceSerialNumber in the RTIMAGE.
+   */
   def setMachineSerialNumber(machine: Machine, rtimage: AttributeList): Unit = {
     if (machine.serialNumber.isEmpty) {
       try {
@@ -125,8 +124,8 @@ object Phase2Util extends Logging {
   }
 
   /**
-    * If a plan was used that was not already saved, then save it to the shared directory so that it will be available for future runs.
-    */
+   * If a plan was used that was not already saved, then save it to the shared directory so that it will be available for future runs.
+   */
   def saveRtplan(plan: DicomFile): Unit = {
     if (plan == null) {
       logger.error("Was given null RTPLAN DicomFile")
@@ -149,8 +148,8 @@ object Phase2Util extends Logging {
   }
 
   /**
-    * Given an RTPLAN and an RTIMAGE, get the name of the beam that the RTIMAGE is referencing in the plan.
-    */
+   * Given an RTPLAN and an RTIMAGE, get the name of the beam that the RTIMAGE is referencing in the plan.
+   */
   def getBeamNameOfRtimage(plan: AttributeList, rtimage: AttributeList): Option[String] = {
     try {
       val ReferencedBeamNumber = rtimage.get(TagByName.ReferencedBeamNumber).getIntegerValues.head
@@ -164,36 +163,36 @@ object Phase2Util extends Logging {
   }
 
   /**
-    * Given an RTPLAN and an RTIMAGE, get the name of the beam that the RTIMAGE is referencing in the plan.
-    */
+   * Given an RTPLAN and an RTIMAGE, get the name of the beam that the RTIMAGE is referencing in the plan.
+   */
   def getBeamNameOfRtimageDf(plan: DicomFile, rtimage: DicomFile): Option[String] = getBeamNameOfRtimage(plan.attributeList.get, rtimage.attributeList.get)
 
   /**
-    * Given an RTPLAN and a beam name, get the beam sequence.
-    */
+   * Given an RTPLAN and a beam name, get the beam sequence.
+   */
   def getBeamSequenceOfPlan(beamName: String, plan: AttributeList): AttributeList = {
     val bs = DicomUtil.seqToAttr(plan, TagByName.BeamSequence).filter(b => Util.normalizedBeamName(b).equals(beamName.trim)).head
     bs
   }
 
   /**
-    * Given an RTPLAN, a list of RTIMAGE(s), and a BeamName, return the RTIMAGE associated with BeamName.
-    */
+   * Given an RTPLAN, a list of RTIMAGE(s), and a BeamName, return the RTIMAGE associated with BeamName.
+   */
   def findRtimageByBeamName(plan: DicomFile, rtimageList: IndexedSeq[DicomFile], BeamName: String): Option[DicomFile] = {
     val beam = rtimageList.map(rti => (rti, getBeamNameOfRtimageDf(plan, rti))).filter(rn => rn._2.isDefined && rn._2.get.equals(BeamName.trim))
     if (beam.nonEmpty) Some(beam.head._1) else None
   }
 
   /**
-    * Given a status, determine if it is 'good'.
-    */
+   * Given a status, determine if it is 'good'.
+   */
   def statusOk(status: ProcedureStatus.Value): Boolean = {
     Seq(ProcedureStatus.pass, ProcedureStatus.done).exists(s => s.toString.equals(status.toString))
   }
 
   /**
-    * Wrap Phase2 HTML with nice headers.
-    */
+   * Wrap Phase2 HTML with nice headers.
+   */
   def wrapSubProcedure(extendedData: ExtendedData, content: Elem, title: String, status: ProcedureStatus.Value, runScript: Option[String], runReq: RunReq): String = {
 
     def mainReport: Elem = {
@@ -206,7 +205,7 @@ object Phase2Util extends Logging {
     val analysisDate: Date = {
       val date = extendedData.output.analysisDate match {
         case Some(d) => d
-        case _       => extendedData.output.startDate
+        case _ => extendedData.output.startDate
       }
       date
     }
@@ -217,7 +216,7 @@ object Phase2Util extends Logging {
     val elapsed: String = {
       val fin = extendedData.output.finishDate match {
         case Some(finDate) => finDate.getTime
-        case _             => System.currentTimeMillis
+        case _ => System.currentTimeMillis
       }
       val elapsed = fin - extendedData.output.startDate.getTime
       Util.elapsedTimeHumanFriendly(elapsed)
@@ -255,13 +254,11 @@ object Phase2Util extends Logging {
           val valueList = value.split("\n");
           {
             <span>
-              {valueList.head}{
-              valueList.tail.map(line => {
-                <span>
+              {valueList.head}{valueList.tail.map(line => {
+              <span>
                 <br/>{line}
               </span>
-              })
-            }
+            })}
             </span>
           }
         }
@@ -322,9 +319,7 @@ object Phase2Util extends Logging {
           </div>
         </div>
         <div class="row">
-          {mainReport}{wrap(2, "Institution", extendedData.institution.name, asAlias = true)}{wrap(1, "Data Acquisition", dataAcquisitionDate, asAlias = false)}{
-        wrap(1, "Analysis", twoLineDate.format(analysisDate), asAlias = false)
-      }{wrap(1, "User", userId, asAlias = true)}{wrap(1, "Elapsed", elapsed, asAlias = false)}{wrap(1, "Procedure", procedureDesc, asAlias = false)}<div class="col-md-1">
+          {mainReport}{wrap(2, "Institution", extendedData.institution.name, asAlias = true)}{wrap(1, "Data Acquisition", dataAcquisitionDate, asAlias = false)}{wrap(1, "Analysis", twoLineDate.format(analysisDate), asAlias = false)}{wrap(1, "User", userId, asAlias = true)}{wrap(1, "Elapsed", elapsed, asAlias = false)}{wrap(1, "Procedure", procedureDesc, asAlias = false)}<div class="col-md-1">
           {OutputList.redoUrl(extendedData.output.outputPK.get)}
         </div>
         </div>
@@ -340,8 +335,8 @@ object Phase2Util extends Logging {
   }
 
   /**
-    * Get a list of bad pixels in the given image according to the configuration for Phase 2.
-    */
+   * Get a list of bad pixels in the given image according to the configuration for Phase 2.
+   */
   def identifyBadPixels(originalImage: DicomImage, radius: Int): Seq[DicomImage.PixelRating] = {
     val numPixels = originalImage.width * originalImage.height
     val maxBadPixels = ((Config.MaxEstimatedBadPixelPerMillion / 1000000.0) * numPixels).round.toInt
@@ -355,8 +350,8 @@ object Phase2Util extends Logging {
   }
 
   /**
-    * HTML snippet to describe a crash.
-    */
+   * HTML snippet to describe a crash.
+   */
   def procedureCrash(name: String): Elem = {
     <div>
       {name + " crashed"}<br/>
@@ -437,8 +432,8 @@ object Phase2Util extends Logging {
   }
 
   /**
-    * Create a list of points whose sum can be used to measure the center dose of an image.
-    */
+   * Create a list of points whose sum can be used to measure the center dose of an image.
+   */
   def makeCenterDosePointList(attributeList: AttributeList, collimatorCenterOfRotation: Point2D.Double): Seq[Point] = {
     val translator = new IsoImagePlaneTranslator(attributeList)
 
@@ -470,8 +465,8 @@ object Phase2Util extends Logging {
   }
 
   /**
-    * Convert a list of pixel values to dose.
-    */
+   * Convert a list of pixel values to dose.
+   */
   def pixToDose(pixValueSeq: Seq[Double], attributeList: AttributeList): Seq[Double] = {
     val m = attributeList.get(TagFromName.RescaleSlope).getDoubleValues.head
     val b = attributeList.get(TagFromName.RescaleIntercept).getDoubleValues.head
@@ -482,20 +477,20 @@ object Phase2Util extends Logging {
   def pixToDose(pixValue: Float, attributeList: AttributeList): Double = pixToDose(Seq(pixValue.toDouble), attributeList).head
 
   /**
-    * Measure dose as specified by the list of points and return it in the proper units.
-    */
+   * Measure dose as specified by the list of points and return it in the proper units.
+   */
   def measureDose(pointList: Seq[Point], dicomImage: DicomImage, attributeList: AttributeList): Double = {
     // average value raw pixel values
     val rawAverage = pointList.map(p => dicomImage.get(p.getX.toInt, p.getY.toInt)).sum / pointList.size
-    val dose = Phase2Util.pixToDose(rawAverage, attributeList)
+    val dose  = Phase2Util.pixToDose(rawAverage, attributeList)
     dose
   }
 
   case class MaintenanceRecordBaseline(maintenanceRecord: Option[MaintenanceRecord], baseline: Baseline) {}
 
   /**
-    * Look through the BeamSequence and find the ReferencedBeamSequence that matches the given beam.
-    */
+   * Look through the BeamSequence and find the ReferencedBeamSequence that matches the given beam.
+   */
   def getBeamSequence(plan: AttributeList, beamNumber: Int): AttributeList = {
     // Determine if the given attribute list references the given beam number.
     def matchesBeam(beamNumber: Int, al: AttributeList): Boolean = al.get(TagByName.BeamNumber).getIntegerValues.head == beamNumber
@@ -504,12 +499,12 @@ object Phase2Util extends Logging {
   }
 
   /**
-    * Return true if the collimator in the image is oriented horizontally, false for vertically.
-    *
-    * This is based on whether the rounded collimator angle is 0 or 180 for horizontal, 90 or 270 for vertical.
-    *
-    * Other collimator angles such as 45 degrees may give unexpected results.
-    */
+   * Return true if the collimator in the image is oriented horizontally, false for vertically.
+   *
+   * This is based on whether the rounded collimator angle is 0 or 180 for horizontal, 90 or 270 for vertical.
+   *
+   * Other collimator angles such as 45 degrees may give unexpected results.
+   */
   def isHorizontal(image: AttributeList): Boolean = (Util.angleRoundedTo90(image.get(TagByName.BeamLimitingDeviceAngle).getDoubleValues.head) % 180) == 0
 
 }
