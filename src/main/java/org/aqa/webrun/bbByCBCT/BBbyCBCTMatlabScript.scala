package org.aqa.webrun.bbByCBCT

import org.aqa.Logging
import org.aqa.Util
import org.aqa.web.ViewOutput
import org.restlet.Response

import java.io.File
import javax.vecmath.Point3d

/**
 * Create a Matlab script that will do the calculations.  This is for visibility for the user.
 */

class BBbyCBCTMatlabScript(outputDir: File, outputPK: Long, cbctAnalysisResult: BBbyCBCTAnalysis.CBCTAnalysisResult, runReq: BBbyCBCTRunReq, response: Response) extends Logging {
  def make(): Unit = {

    val ls = System.lineSeparator
    val vs = cbctAnalysisResult.volumeTranslator.voxSize

    def d2Txt(name: String, pt: Point3d): String = {
      name + " = [ " + pt.getX + " " + pt.getY + " " + pt.getZ + " ];"
    }

    val header = {
      s"""
% Calculate CBCT results with Matlab code.  This code may be run with Matlab.  This code is provided as a convenience to
% allow users to ascertain that calculations are being done correctly.
%
% Note that the AQA generates these values using entirely different code (written in Scala), but because the answers match,
% users can be assured that the calculations are equivalent.  The only difference might be in roundoff errors, but the
% results will match to at least 10 significant figures.
%
% CBCT report: ${response.getRequest.getHostRef}${ViewOutput.viewOutputUrl(outputPK)}
"""
    }

    val coarseLocation_vox = {
      val d = new Point3d(cbctAnalysisResult.coarseLocation_vox.getX, cbctAnalysisResult.coarseLocation_vox.getY, cbctAnalysisResult.coarseLocation_vox.getZ)
      s"""
% Approximate location of bb in voxel coordinates (not used in calculations).  This is an internal
% value generated by finding a small group of pixels with the greatest intensity as an
% approximation of the BB's location.
% ${d2Txt("approximateLocation_vox", d)}"""
    }

    val preciseLocation_vox = {
      "% Precise location of bb in voxel coordinates" + ls +
        d2Txt("preciseLocation_vox", cbctAnalysisResult.fineLocation_vox)
    }

    val ipp = cbctAnalysisResult.volumeTranslator.ImagePositionPatient.toArray
    //val ImagePositionPatient = d2Txt("", new Point3d(ipp))

    val voxelSize = {
      "% XYZ dimensions of a voxel in mm" + ls +
        "PixelSpacingX = " + cbctAnalysisResult.volumeTranslator.voxSize.getX + ";" + ls +
        "PixelSpacingY = " + cbctAnalysisResult.volumeTranslator.voxSize.getY + ";" + ls +
        "SliceThickness = " + cbctAnalysisResult.volumeTranslator.voxSize.getZ + ";"
    }

    val cbctFor = {
      "% XYZ coordinates of bb in CBCT frame of reference in mm" + ls +
        "xFor = preciseLocation_vox(1) * " + vs.getX + " + " + ipp(0) + ";" + ls +
        "yFor = preciseLocation_vox(2) * " + vs.getY + " + " + ipp(1) + ";" + ls +
        "zFor = preciseLocation_vox(3) * " + vs.getZ + " + " + ipp(2) + ";" + ls +
        "cbctFor = [ xFor yFor zFor 1.0 ];" + ls
    }

    val matrix = {
      val m = runReq.imageRegistration.get.getMatrix

      "FrameOfReferenceTransformationMatrix = [ " + ls +
        m.m00 + "    " + m.m10 + "    " + m.m20 + "    " + m.m30 + ";" + ls +
        m.m01 + "    " + m.m11 + "    " + m.m21 + "    " + m.m31 + ";" + ls +
        m.m02 + "    " + m.m12 + "    " + m.m22 + "    " + m.m32 + ";" + ls +
        m.m03 + "    " + m.m13 + "    " + m.m23 + "    " + m.m33 + " ];"
    }

    val cbctRtplanFor = {
      "% Position of CBCT in RTPLAN FOR (frame of reference) in mm" + ls +
        "cbctRtplanFor = cbctFor * FrameOfReferenceTransformationMatrix;" + ls +
        "cbctRtplanFor = [ cbctRtplanFor(1) cbctRtplanFor(2) cbctRtplanFor(3) ];  % Discard fourth vector value" + ls
    }

    val isocenterPositionDbl = Util.getPlanIsocenterList(runReq.rtplan).head
    val isocenterPosition = {
      "% Isocenter of plan in RTPLAN frame of reference in mm" + ls +
        d2Txt("IsocenterPosition", isocenterPositionDbl)
    }

    val error = {
      "% XYZ error of CBCT - PLAN isocenter" + ls +
        "XYZerror = cbctRtplanFor - IsocenterPosition;" + ls +
        """fprintf("XYZerror: %f  %f  %f\n", XYZerror(1),XYZerror(2),XYZerror(3));"""
    }

    val text = Seq(header, coarseLocation_vox, preciseLocation_vox, voxelSize, cbctFor, matrix, cbctRtplanFor, isocenterPosition, error).mkString(ls + ls) + ls

    val file = new File(outputDir, BBbyCBCTHTML.matlabFileName)
    logger.info("Writing matlab code file: " + file.getAbsolutePath + "\n" + text)
    Util.writeFile(file, text)
  }

}
